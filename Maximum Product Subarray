Example 1:

Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.


Approach:

Scan from both sides because negatives flip the sign.
One negative → bad.
Two negatives → good again.
So left scan alone may miss the best subarray. Right scan catches it.

Keep multiplying while moving.
If product becomes 0, reset to 1 because zero breaks the chain.

Track the maximum at every step.

Code:

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n=len(nums)
        left_product=1
        right_product=1
        ans=nums[0]

        for i in range(n):
            if left_product==0:
                left_product=1
            if right_product==0:
                right_product=1

            left_product*=nums[i]
            right_product*=nums[n-i-1]
            ans = max(ans, left_product, right_product)

        return ans
        
